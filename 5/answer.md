1) /usr/lib/postgresql/17/bin/pgbench -c 8 -j 4 -T 10 -f ~/workload.sql -n -U postgres thai
 
       На 8 подключенияк 12к tpx
       еще првоерил на 2 потоках, у меня ВМ на двух ядрах, 16000 тпс

2) /usr/lib/postgresql/17/bin/pgbench -c 100 -j 4 -T 10 -f ~/workload.sql -n -U postgres thai
     
       на 100 коннектов 10.6 к
       хотя тут при 2 потоках 9к тпс
     
       c 100 худщая производительность, перегружаем базу   Самое большое время установки соеденений
       и важно еще заметить корреляцию между потоками и коннектами, например при 8 коннектов 4 потока показатели хуже
 
3) /usr/lib/postgresql/17/bin/pgbench -c 8 -j 4 -T 10 -f ~/workload.sql -n -U postgres thai
      
         8 коннектов пг баунсер 16к тпс

4) /usr/lib/postgresql/17/bin/pgbench -c 8 -j 4 -T 10 -f ~/workload.sql -n -U postgres -p 5432 -h localhost thai 
   
         8 коннектов TCP 12k tpc

   Линукс сокеты быстрее, нет накладных расходов на сеть

5) /usr/lib/postgresql/17/bin/pgbench -c 8 -j 4 -T 10 -f ~/workload.sql -n -U postgres -p 6432 -h 127.0.0.1 thai

         8 коннектов PgBouncer 9.7k tpc

         При 8 подключениях  PgBouncer проигрывает из-за своих накладных расходов

6) /usr/lib/postgresql/17/bin/pgbench -c 900 -j 4 -T 10 -f ~/workload.sql -n -U postgres -p 5432 -h localhost thai
      
         0.6k tpc напрямую в базу при 900 коннекшенах

7)  /usr/lib/postgresql/17/bin/pgbench -c 200 -j 4 -T 10 -f ~/workload.sql -n -U postgres -p 5432 -h localhost thai

         5,5k tps через pgbounser при 900 коннекшенах
         
         Тут Видно что при большом количестве коннектов пгбаунсер выигрывает

8) Провел тестирование в трех режимах, сначала с 1 запросом в workload.sql, затем 3 запроса
 Тест был при 100 и 900 подключениях


| Pool Mode   | Количество подключений | TPS (один запрос) | Latency (ms) | TPS (три запроса) | Latency (ms) |
|-------------|------------------------|-------------------|--------------|-------------------|--------------|
| Statement   | 900                    | 4406.82           | 204.23       | 1509.39           | 596.27       |
| Transaction | 900                    | 4632.14           | 194.29       | 2050.06           | 439.01       |
| Session     | 900                    | 3947.56           | 227.99       | 1958.15           | 459.62       |
| Statement   | 100                    | 6870.65           | 14.56        | 2838.96           | 35.22        |
| Transaction | 100                    | 7140.05           | 14.01        | 2773.81           | 36.05        |
| Session     | 100                    | 7511.34           | 13.31        | 3170.85           | 31.54        |

             При высоком  количестве подключений где в бенче 1 запрос, выигравает Transaction, потом Statement с небольшой 
         разницей (не совсем понимаю почему, ведь тут 1 запрос и разницы не должно быть), а потом Session думаю из-за того что он держит подключение
         и идут наклодные расходы на поддержку коннекта до конца сессии( по бенчу это 10 сек).
            При трех запрсах Transaction и  Statement лидируют с минимальным разрывом, можно списать на погрешность, Statement сильно
         проигрывает ведь ему надо создавать три подключения на 1 бенч


            При низком  количестве подключений где в бенче 1 запрос, выигравает Session, я правда не совсем понимаю почему,
         По моей логике Statement должен быть самым быстрым. 
            При трех запрсах   Session тоже быстрее, на втором месте Statement, хотя я бы подумал что тут уже Transaction должен быть быстрым самым. 

